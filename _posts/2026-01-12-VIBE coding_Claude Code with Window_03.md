---
layout: single
title: "[VIVE Conding] Claude Coding - 03" 
categories: VIVE Coding
typora-root-url: ../
toc: true
---

### 목표

**1. 배경**

​	VIBE Coding(AI 협업 코딩) 환경이 도래하면서 백엔드와 프론트엔드의 기술적 경계가 모호해지고 있음.

**2. 필요성**

​	**효율성 증대:** 사소한 수정 사항까지 Claude Code(AI)에 의존하여 불필요한 토큰을 소모하는 비효율을 개선해야 함.

​	**프롬프트 역량 강화:** 개발자가 전반적인 구조를 이해해야 AI에게 더 정교한 지시를 내리고, 답변을 검증할 수 있음.

**3. 핵심 목표**

​	프론트엔드 생태계의 표준인 **React의 개념**과 **Next.js의 탄생 배경**을 정확히 이해하고, 이를 실무에 적용할 수 있는 기초 체력을 기른다.



### 1. 큰 그림 먼저: React vs Next.js

가장 먼저 헷갈리는 부분부터 정리하고 가죠.

- **React (리액트):** "UI를 만들기 위한 **라이브러리(Library)**"입니다. 레고 블록(컴포넌트)을 만드는 도구라고 생각하면 됩니다.
- **Next.js (넥스트 제이에스):** "React를 기반으로 한 **프레임워크(Framework)**"입니다. 레고 블록(React)만으로는 집을 짓기 어렵습니다. Next.js는 기둥, 배관, 전기 배선(라우팅, 최적화, 서버 기능 등)이 미리 갖춰진 '건축 키트'입니다.

> **비유하자면:**
>
> - **React:** 엔진 (자동차를 움직이는 핵심 부품)
> - **Next.js:** 자동차 (엔진에 바퀴, 핸들, 차체를 조립해서 바로 탈 수 있게 만든 완성품)

우리는 **React로 부품(Component)을 만들고, Next.js라는 틀 안에서 조립**하게 될 것입니다.



------

### 2. React의 핵심 철학: "컴포넌트(Component)"

기존 웹 개발(HTML/jQuery)과 React의 가장 큰 차이점은 **컴포넌트 기반(Component-Based)**이라는 점입니다.

#### 기존 방식 (HTML)

화면 전체를 하나의 문서로 봅니다. 코드가 길어지면 관리가 힘듭니다.

HTML

```
<div class="header">메뉴...</div>
<div class="main">안녕하세요...</div>
<div class="footer">Copyright...</div>
```

#### React 방식 (Component)

화면을 독립적인 **기능 단위(부품)**로 쪼갭니다.

JavaScript

```
// 1. Header 부품(컴포넌트)을 먼저 정의합니다.
function Header() {
  return <header>나는 헤더입니다.</header>;
}

// 2. Main 부품을 정의합니다.
function Main() {
  return <main>여기는 본문 내용이 들어갑니다.</main>;
}

// 3. Footer 부품을 정의합니다.
function Footer() {
  return <footer>카피라이트 2026</footer>;
}

// 4. App(전체 화면)에서 위 부품들을 조립합니다.
export default function App() {
  return (
    <div>
      <Header />
      <Main />
      <Footer />
    </div>
  );
}
```

**[장점]**

1. **재사용성:** `<Button />`이라는 컴포넌트를 한 번 만들면, 로그인 페이지든 결제 페이지든 어디서나 갖다 쓸 수 있습니다.
2. **유지보수:** 헤더가 고장 나면 `Header` 컴포넌트만 고치면 됩니다. 전체 코드를 뒤질 필요가 없습니다. (시스템 엔지니어링의 모듈화와 같습니다.)



------

### 3. React의 데이터 흐름: Props와 State

React가 화면을 그리는 원리는 딱 두 가지 데이터에 의존합니다. 이 두 가지만 이해하면 React의 80%는 끝난 셈입니다.

#### ① Props (프롭스, Properties)

- **정의:** 부모 컴포넌트가 자식 컴포넌트에게 내려주는 **"읽기 전용 데이터"**입니다.
- **비유:** 팀장님(부모)이 팀원(자식)에게 주는 "작업 지시서"입니다. 팀원은 지시서 내용을 바꿀 수 없고, 받은 대로 수행(렌더링)해야 합니다.

#### ② State (스테이트)

- **정의:** 컴포넌트 **"내부에서 관리하는, 변할 수 있는 데이터"**입니다.
- **비유:** 팀원(컴포넌트)의 "현재 컨디션"이나 "메모장"입니다. 내 기분(State)이 바뀌면 내 표정(UI)도 즉시 바뀝니다.

> **[중요]** React의 마법은 여기서 일어납니다. **State(데이터)가 변경되면, React는 자동으로 UI를 업데이트합니다.** (우리가 직접 화면을 고칠 필요가 없습니다!)



---

### 4. Next.js의 핵심 무기 1: 파일 시스템 라우팅 (File System Routing)

React만 쓸 때는 "어떤 주소(/about)로 들어오면 어떤 컴포넌트(AboutPage)를 보여줘라"라는 코드를 복잡하게 짜야 했습니다. Next.js는 이 규칙을 혁신적으로 바꿨습니다. **"폴더가 곧 URL 주소다."**

- **규칙:** `app` 폴더 안에 폴더를 만들면, 그게 바로 웹사이트 주소가 됩니다.
- **파일:** 각 폴더 안에 `page.js`라는 파일을 만들면, 그게 그 주소의 화면이 됩니다.

**[구조 비교]**



```Plaintext
📂 app
 ├── 📄 page.js        → 메인 홈페이지 (www.example.com/)
 ├── 📂 about          → /about 주소 생성
 │    └── 📄 page.js   → 회사 소개 페이지 화면
 └── 📂 contact        → /contact 주소 생성
      └── 📄 page.js   → 연락처 페이지 화면
```

> **비유:** 윈도우 탐색기에서 폴더 정리하듯이 웹사이트 페이지를 만듭니다. 개발자가 라우터 설정을 코딩할 필요가 없습니다.



---

### 5. Next.js의 핵심 무기 2: 레이아웃 시스템 (layout.js)

웹사이트를 보면 헤더(메뉴)나 푸터(바닥글)는 페이지가 바뀌어도 그대로 유지되죠? React에서는 이걸 매 페이지마다 넣어야 하는 번거로움이 있었는데, Next.js는 `layout.js`로 해결합니다.

- **역할:** 특정 폴더(주소) 그룹 전체에 공통적으로 적용되는 '틀'입니다.
- **작동 원리:** `layout.js` 안에 `page.js`가 끼워져서 렌더링됩니다.



```javascript
// app/layout.js (최상위 레이아웃)
export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <Header />  {/* 모든 페이지에 무조건 뜸 */}
        {children}  {/* 여기에 각 페이지(page.js) 내용이 갈아 끼워짐 */}
        <Footer />  {/* 모든 페이지에 무조건 뜸 */}
      </body>
    </html>
  );
}
```



---

### 6. Next.js의 핵심 무기 3: 서버 사이드 렌더링 (SSR) & 서버 컴포넌트

이게 Next.js를 쓰는 가장 큰 기술적 이유입니다.

- **React (기존 CSR):** 브라우저가 빈 화면을 먼저 받고, 자바스크립트를 다운받아 실행한 뒤에야 화면을 그립니다. (초기 로딩이 느리고, 검색엔진(Google)이 내용을 잘 못 읽음)

  > *비유: 이케아 가구를 주문했는데, 집에 부품 박스만 배달 옴. 내가 집에서 조립해야 사용할 수 있음.*

- **Next.js (기본 SSR/RSC):** 서버에서 미리 HTML을 다 완성해서 브라우저로 보냅니다. 사용자는 들어오자마자 완성된 화면을 봅니다.

  > *비유: 공장에서 이미 조립된 완제품 가구가 배달 옴. 받자마자 바로 앉을 수 있음.*
